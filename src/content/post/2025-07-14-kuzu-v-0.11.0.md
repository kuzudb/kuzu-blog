---
slug: "kuzu-0.11.0-release"
title: "Kuzu 0.11.0 Release"
description: "Release announcement for Kuzu 0.11.0"
pubDate: "July 14 2025"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher"]
---

Kuzu v0.11.0 is here! The team is excited to unveil this release, which is packed with a ton of new
features and improvements.

## Single-file databases

Starting from version 0.11.0, a database in Kuzu is _just a file_ on disk. This single-file design has
been long-adopted in other embedded database systems, such as DuckDB and SQLite, making your Kuzu
databases much more portable and easier to share or archive. To easily distinguish your Kuzu database files 
from other files, we recommend using the `.kuzu` or `.kz` extension.

Note that this change is not backward-compatible, so you can use the [export](https://docs.kuzudb.com/migrate/)
command to migrate your existing Kuzu database directories from older versions to v0.11.0. If you're interested,
you can learn more about the different on-disk files created and managed by Kuzu [here](https://dev-docs.kuzudb.com/developer-guide/files/).

## Vector index and FTS improvements

There have been numerous PRs in this release focusing on improving the vector and
full-text search (FTS) indices. We list some of the highlights below.

### Mutable indices

Vector and full-text search (FTS) indices in Kuzu are now _mutable_, meaning that the index is updated the moment new data
is added to the graph. Once an index is created on a table, any further insertion and deletion operations
in that table will automatically trigger an update in the associated index.

If your workflows involve manually dropping and recreating indices on tables that are updated
with new data, now, you can just focus on inserting the data, and Kuzu will take care of the rest.

### Filtered vector search with arbitrary Cypher queries

Our initial version of vector search provided the ability to perform filtered search with simple predicates
on a single table. In v0.11.0, we generalize the predicate to be an arbitrary Cypher query. Consider the following
graph with a `(:Book)-[:PublishedBy]->(:Publisher)` relationship, and a vector index on the `Book` table.

```sql
CREATE NODE TABLE Book(id SERIAL PRIMARY KEY, title STRING, title_embedding FLOAT[384]);
CREATE NODE TABLE Publisher(name STRING PRIMARY KEY);
CREATE REL TABLE PublishedBy(FROM Book TO Publisher);
CALL CREATE_VECTOR_INDEX(
    'Book', -- table name
    'book_title_index', -- index name
    'title_embedding' -- property name on which the vector index is created
);
```

To retrieve relevant books from a certain publisher, e.g. `Pearson`, you simply define the predicate
using a Cypher query. The example below shows a projected graph, defined via `PROJECT_GRAPH_CYPHER`,
and reference the name of the projected graph in the `QUERY_VECTOR_INDEX` call.

```sql
CALL PROJECT_GRAPH_CYPHER(
    'pearson_book',   -- graph name
    'MATCH (b:Book)-[:PublishedBy]->(p:Publisher {name:'Pearson'}) RETURN b' -- cypher query
)
CALL QUERY_VECTOR_INDEX(
    'pearson_book', -- graph name
    'book_title_index', -- index name
    create_embedding('quantum world', 'open-ai', 'text-embedding-3-small', 384), -- input vector
    2 -- top K
)
```

You can learn more about this feature using a more detailed example in the [docs](https://dev-docs.kuzudb.com/extensions/vector/#filtered-vector-search-with-arbitrary-cypher-query).

### FTS performance improvements

This release improves the top-K search performance of FTS indices. To illustrate the performance improvement
from the previous release, we report the end-to-end runtimes on a machine with 2xAMD EPYC 9J14 CPUs and 768GB RAM,
using 1, 2, 4 and 8 threads to compute top 10 most relevant record through a full-text-search index on [ms-passage](https://microsoft.github.io/msmarco/) dataset with abount 8M records.


| # threads | 1 | 2 | 4 | 8 |
|------|------|------|------|------|
|  v0.10   |  6.2s   |  4.2s   |  2.8s   |  2.1s   |
|  v0.11   |  3.3s   |  2.2s   |  1.3s   |  1.0s   |


## LLM extension

As more and more users build AI applications on top of Kuzu, we've seen a growing demand for convenience
features to help interact with popular LLM providers. In this release, we're happy to announce a new
`LLM` extension that allows you to directly call LLM APIs using Cypher.

For now, only a single function is supported in this extension: `CREATE_EMBEDDING`. This function takes a text string as input,
and returns a vector of floats, i.e., embeddings, that can be used via a vector index for similarity search.

```cypher
// Install the extension
INSTALL llm;
LOAD llm;

// Create an embedding via Ollama
RETURN CREATE_EMBEDDING(
    "Kuzu is an embedded graph database",
    "ollama",
    "nomic-embed-text"
);

// OR, create an embedding via OpenAI
RETURN CREATE_EMBEDDING(
    "Kuzu is an embedded graph database",
    "openai",
    "text-embedding-3-small"
);
```

This feature should make it simpler to update your database with new embeddings as you obtain new data,
without having to write custom Python scripts to manage your embedding pipeline outside of Kuzu. To
learn more about which model providers are supported, check out the [docs](https://dev-docs.kuzudb.com/extensions/llm/) page.

## Azure 

We've rolled out initial support for scanning data from Azure Blog Storage and Azure Data Lake Storage (ADLS).
If you're using Kuzu in Azure environments, check out this feature in the [docs](https://dev-docs.kuzudb.com/extensions/azure/) and reach out to us via a [GitHub issue](https://github.com/kuzudb/kuzu/issues) or discussion if you have any feedback.

## Swift API

Kuzu is designed to run anywhere, on almost any machine. With this goal in mind, we're excited to introduce
our new Swift API, which allows you to run Kuzu on Apple devices.

## Other Cypher features

### Create table as

Similar to PostgreSQL, Kuzu now support create table and fill its data through `CREATE NODE/REL TABLE AS <subquery>`. The created table have the same column names and types as the result of `subquery`. 

For example, the following query creates a new node table `YoungPerson` with a subset of record from `Person` table. 
```sql
CREATE NODE TABLE YoungPerson AS
    MATCH (p:Person)
    WHERE p.age < 25
    RETURN p.*;
```

More information can be found [here](http://dev-docs.kuzudb.com/cypher/data-definition/create-table/#create-node-table-as)

### Alter relationship table add/drop connection

Kuzu now offers a more flexible schema by allowing modifying the from/to connection of a relationship table.

The following example adds a `User->Celebrity` connection to `Follows` table and then remove it.
```
ALTER TABLE Follows ADD FROM User TO Celebrity;
ALTER TABLE Follows DROP FROM User TO Celebrity;
```

More information can be found [here](http://dev-docs.kuzudb.com/cypher/data-definition/alter/#add-connection-to-relationship-table)

## Closing remarks

Over the coming months, our main goal is to empower developers working with the next generation of AI agents
and LLMs. Along the way, we'll continue to improve Kuzu's performance and usability features, so that
you're more productive with your graph-based workflows.

As Kuzu's userbase continues to grow, we're excited to welcome new users to our community, and we encourage
you to join us on [Discord](https://kuzudb.com/chat) to share your thoughts and ideas as we build the future
of graph databases. We're eager to see what you build with this latest release, and we love
hearing from our users about what we can do to make Kuzu even better -- keep the feedback coming.

See you next time!

-- The Kuzu Team


