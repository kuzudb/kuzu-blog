---
slug: "kuzu-0.10.0-release"
title: "Kuzu 0.10.0 Release"
description: "Release announcement for Kuzu 0.10.0, introducing graph data science extension"
pubDate: "May 5 2025"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher"]
---


## Graph Algorithms

Graph algorithms are essential tools for extracting meaningful insights from connected data. Whether you're detecting fraud patterns in financial transactions, optimizing supply chain networks, or analyzing social media interactions, these algorithms help you understand complex relationships and make data-driven decisions.
With our graph algorithms (`ALGO`) extension, you can now perform these analyses efficiently at scale, without needing to export your data to specialized graph analytics tools.

The graph algorithms extension has three important features:

- **Parallalize at scale**: algorithms are executed through a parallel framework based on [Ligra paper](https://jshun.csail.mit.edu/ligra.pdf) and ensures great scalability for large scale dataset. 
- **Disk-based**: algorithms are disk-based and implemented with Kuzu storage engine. Therefore, memory is not a limitation as your graph scales.
- **Native cypher integration**: All algorithms are abstracted as functions and thus can be combined with arbitrary cypher pattern matching.

The initial release includes the following algorithms

- Weakly connected components
- Strongly connected components (a parallel BFS-based and a single-thread DFS-based implementation)
- PageRank
- K-Core decomposition
- Louvain
- (All) Weighted shortest path

### Benchmark

We demostrate the performance and scalability of our algorithm package with various datasets and thread configurations.

**Datasets**

Below are three datasets from different domains with size ranges from thousands to billion level.

| Dataset | # Nodes | # Edges | Raw File Size |
|---------|---------|---------|---------------|
| soc-sign-bitcoin-otc | 5K | 35K | 1MB |
| soc-LiveJournal1 | 4.8M | 68M | 1.1GB |
| datagen-sf10k | 100M | 9.4B | 294.3GB |

We report the end-to-end runtime on a machine with 2xAMD EPYC 9J14 CPUs and 768GB RAM, using 4, 16 and 64 threads for execution.

**soc-sign-bitcoin-otc**

| Algorithm | 4 threads | 16 threads | 64 threads |
|-----------|-----------|------------|------------|
| WCC |  12.2ms | 15.7ms | 20.0ms |
| SCC | 39.3ms | 46.7ms | 49.6ms |
| SCC-ko | 15.5ms | 38.1ms | 34.5ms |
| PageRank | 50.1ms | 51.0ms | 49.6ms |
| K-Core | 181.3ms | 207.8ms | 213.0ms |
| Louvain | 123.0ms | 137.2ms | 143.7ms |
| WSP | 16.4ms | 16.8ms | 19.2ms |

**soc-LiveJournal1**

| Algorithm | 4 threads | 16 threads | 64 threads |
|-----------|-----------|------------|------------|
| WCC | 3.6s  | 0.9s | 0.3s |
| SCC | 9.6s | 2.6s | 0.9s |
| SCC-ko | 8.3s | 8.2s | 8.2s |
| PageRank | 19.9s | 6.9s | 5.1s |
| K-Core | 46.7s | 13.3s | 9.2s |
| Louvain | 102.2s | 42.7s | 21.2s |
| WSP | 13.6s | 3.8s | 1.1s |

**datagen-sf10k[^1]**

[^1]: Louvain algorithm requires more than 256GB of memory on datagen-sf10k so we omit Louvain in this dataset.

| Algorithm | 4 threads | 16 threads | 64 threads |
|-----------|-----------|------------|------------|
| WCC | 201.4s | 54.3s | 19.7s |
| SCC |  |  | 849.3s |
| SCC-ko | 273.5s | 271.2s | 280.0s |
| PageRank | 992.5s| 299.4s | 146.5s |
| K-Core | 585.6s | 151.8s | 52.7s |
| WSP | 4.8s | 2.5s | 0.7s |

### Example

All algorithms, except for that [(all) weighted shortest path](http://docs.kuzudb.com/cypher/query-clauses/match#shortest-path) is provided as built-in algorithm, are provided in [`ALGO` extension](http://docs.kuzudb.com/extensions/algos). 
We illustrate the usage of graph algorithms extension with an example using the LDBC SNB dataset.
The example finds top 10 influencers based on `person-knows->person` subgraph and extracts all posts they have commented on.

```cypher
// Install graph algorthm extension
INSTALL ALGO;
LOAD ALGO;

// Create a projected graph with person and knows tables.
CALL create_projected_graph(
    'KnowsGraph', 
    ['person'], 
    ['knows']
);

// Run page rank on projected graph to find the top 10 influencers.
// Then traverse `postHasCreator` to extract all posts
CALL page_rank('KnowsGraph')
WITH node AS person, rank
ORDER BY rank DESC
LIMIT 10
MATCH (person)<-[:postHasCreator]-(post:Post)
RETURN person, post;
```

### Graph algorithm on filtered graph

Graph algorithms can also run on a subset of table records using filtered graph. 

Following the example above, we can find influencers within a certain age group, e.g. 18-24, with a filtered projected graph. 
```cypher
// Create a filtered graph selecting person within the age group
CALL create_projected_graph(
    'FilteredKnowsGraph', 
    { 'person': 'n.birthday >= date("2001-01-01") AND n.birthday <= date("2007-12-31")' },
    ['knows']
);

// Run page rank on filtered projected graph
CALL page_rank('FilteredKnowsGraph')
WITH node AS person, rank
ORDER BY rank DESC
LIMIT 10
MATCH (person)<-[:postHasCreator]-(post:Post)
RETURN person, post;
```

## Neo4j migration 

To help user migrate their data from Neo4j more smoothly, we introduce a [`Neo4j`](http://docs.kuzudb.com/extensions/neo4j) extension that can automatically import nodes and relationships from your neo4j database into Kuzu tables.

To migrate a Neo4j database, simply install the  `neo4j` extension in Kuzu and then run the following query with a set of node and relationship labels you want to migrate.
```cypher
CALL neo4j_migrate(
    'host_name',
    'user_name',
    'password',
    ['node_label_1', 'node_label_2', ...],
    ['rel_label_1', 'rel_label_2', ...]
)
```

The Neo4j migration functionality relies on the APOC extension to be installed in Neo4j desktop or server.
You can find more details on setup needed on Noe4j desktop or server [here](http://docs.kuzudb.com/extensions/neo4j#set-up-neo4j-apoc-extension)

## Scan compressed CSV

Large CSV files are usually distributed in compressed formats. Kuzu now supports scanning directly from gzipped csv files without manual decompression.

Consider a `user.csv` file, its gzipped version `user.csv.gz` can be obtained by
```shell
gzip -k user.csv
```

The compressed file can then be read by Kuzu through
```cypher
LOAD FROM 'user.csv.gz' RETURN *;
```
It can also be directly copied into a Kuzu table:
```cypher
COPY User FROM 'user.csv.gz';
```

## Android support

Kuzu now supports Android devices with ARMv8-A architecture through our Java API. Developers can now build mobile applications that leverage Kuzu's graph database capabilities directly on Android devices.
The precompiled binaries are compiled targetting [API level 21](https://developer.android.com/tools/releases/platforms).

## Performance Improvements

### Free Space Management
Reusing disk space has been a long missed feature in Kuzu.
It can prevent database size from becoming bloated after frequent data modifications.
We're now introducing the free space management mechanism that is able to reclaim free space in three key scenarios:
- When tables are dropped;
- When tuples within a node group are all deleted;
- When column chunks are rewritten due to updates or insertions.

The space reclamation process occurs automatically during the CHECKPOINT phase, ensuring minimal impact on regular transactions.

Note that:
- The current implementation focuses on managing free space in the `data.kz` file, which stores main data of node and rel tables. We plan to extend this functionality to index files in future releases.
- We never shrink our `data.kz` file. Instead, we keep track of free space within the file and try to reuse it during future allocations.

To demonstrate the effectiveness of our new free space management mechanism, we conducted a micro-benchmark using the LDBC dataset at scale factor 100.
We compared the disk space usage between v0.9.0 and v0.10.0 across three different workloads:
1. **Multi COPY**: We partition the `person` csv file into `10` partitions, each of which is saved as a csv file. We copy each partitioned csv file one at a time, and report the final size of `data.kz` file.
2. **Drop Tables**: We create a node table `person`, copy tuples into the table, drop the table, and perform `CHECKPOINT`. We repeat these operations for 5 times, and report the final size of `data.kz` file.
3. **Bulk Deletions**: We create a node table `person`, copy tuples into the table, delete all tuples from the table, and perform `CHECKPOINT`. We repeat these operations for 5 times, and report the final size of `data.kz` file.

| Workloads | 0.9.0 | 0.10.0 |
| --------- | ----- | ------ |
| Multi COPY | 32MB | 20MB |
| Delete | 85MB | 20MB |
| Drop | 75MB | 18MB |

It is noticable that Kuzu can make better use of disk space with the help of free space management now.

### Recursive queries

In v0.9, we introduced a parallel framework for recursive queries aiming to mitigate the long tail problem when recursive queries access a highly skewed node, i.e. node with high degree. 
This framework will blindly allocate a concurrent data structure whose size is linear to the number of nodes in relevant tables. 
However, this incurs an overhead when running a small recursive query on very large database in which case, the allocation becomes the bottleneck. 

For example, in v0.9, on LDBC100 with 220M Comment records, a simple index nested loop join query takes about **1ms** but its equivalent recursive query takes **300ms** due to the large size of Comment table.

```
// Non-recursive
MATCH (:Comment {id:<id>})-[:replyOf]->(:Comment)
// Recursive
MATCH (:Comment {id:<id>})-[:replyOf*1..1]->(:Comment) // 300ms
``` 

In v0.10, we close the gap by starting with a small allocation and dynamically grow the data structure. This brings the recursive query performance back to **1ms**.

| Query | 0.9.0 | 0.10.0 |
| ----- | ----- | ------ |
| Non-recursive | 1ms   | 1ms    |
| Recursive     | 300ms | 1ms    |

### JSON scan

We have seen many use cases that import json formatted data into Kuzu. Over the past month, we improve the
scan performance of json files and achieves 4 times improvements

Below shows a micro benchmark that scans LDBC-100 dataset in json format.

|  | 1 thread | 2 threads | 4 threads |
|---------|----------|-----------|-----------|
| v0.9    | 190s    | 99s      | 52s      |
| v0.10   | 56s    | 27s      | 15s     |

## Closing remarks

TODO: Prashanth. Do we want to mention G.V integration?