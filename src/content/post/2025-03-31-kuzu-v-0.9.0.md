---
slug: "kuzu-0.9.0-release"
title: "Kuzu 0.9.0 Release"
description: "Release announcement for Kuzu 0.9.0"
pubDate: "Mar 31 2025"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher"]
---


## Vector Index
As there is a growing demand for vector similarity searches in databases, we are excited to announce our new `VECTOR` extension, which allows you to perform similarity search over vector data in Kuzu.

We adopt the [hierachical navigable small world (HNSW)](https://dl.acm.org/doi/10.1109/tpami.2018.2889473) vector index design with two layers.
The lower layer consists of all vectors (each vector can be viewed as a node) and a set of edges that connect pairs of vectors that are close to each other.
The upper layer is same as the lower layer except for that it only consists of a subset of the vectors that are sampled from the full set.
As each layer is essential a graph structure, which is native to Kuzu, we store each layer as a relationship table in Kuzu.
In this way, we make use of Kuzu's native storage and query capabilities to store and search the index.

To start using our vector index, you have to first install and load the extension:
```cypher
INSTALL VECTOR;
LOAD VECTOR;
```

In the extension, we provide three basic functions to create, query, and drop a vector index:
```cypher
CALL CREATE_VECTOR_INDEX(
    'table_name',      // Name of the table containing the vector column
    'index_name',      // Name to identify the vector index
    'column_name',     // Name of the column containing vector embeddings
    [option_name := option_value]  // Optional parameters for index configuration
);
CALL QUERY_VECTOR_INDEX(
    'table_name',      // Name of the table
    'index_name',      // Name of the vector index
    query_vector,      // Vector to search for
    k,                 // Number of nearest neighbors to return
    [option_name := option_value]  // Optional parameters
) RETURN node.id ORDER BY distance;
CALL DROP_VECTOR_INDEX('table_name', 'index_name');
```

We use an example through our Python API below to demonstrate how these functions work.
First, we populate the database with some sample data, consisting of two node tables `Book` and `Publisher`, and a relationship table `PublishedBy`.
```python
# pip install sentence-transformers
# pip install kuzu
import kuzu
from sentence_transformers import SentenceTransformer
# Load a pre-trained embedding generation model. https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2
model = SentenceTransformer("all-MiniLM-L6-v2")

db = kuzu.Database()
conn = kuzu.Connection(db)
conn.execute("INSTALL VECTOR;")
conn.execute("LOAD VECTOR;")
# Create tables Book, Publisher, and PublishedBy
conn.execute("CREATE NODE TABLE Book(id SERIAL PRIMARY KEY, title STRING, title_embedding FLOAT[384]);")
conn.execute("CREATE NODE TABLE Publisher(name STRING PRIMARY KEY);")
conn.execute("CREATE REL TABLE PublishedBy(FROM Book TO Publisher, published_year INT64);")
titles = ["The Quantum World", "Chronicles of the Universe", "Learning Machines", "Echoes of the Past", "The Dragon's Call"]
publishers = ["Harvard University Press", "Independent Publisher", "Pearson", "McGraw-Hill Ryerson", "O'Reilly"]
published_years = [2004, 2022, 2019, 2010, 2015]
# Create nodes for Book and Publisher
for title in titles:
    # Convert title to a 384-dimensional embedding vector
    embeddings = model.encode(title).tolist()
    conn.execute("""CREATE (b:Book {title: $title, title_embedding: $embeddings});""", {"title": title, "embeddings": embeddings})
for publisher in publishers:
    conn.execute("""REATE (p:Publisher {name: $publisher});""", {"publisher": publisher})
# Create relationships between Book and Publisher
for title, publisher, published_year in zip(titles, publishers, published_years):
    conn.execute("""
        MATCH (b:Book {title: $title})
        MATCH (p:Publisher {name: $publisher})
        CREATE (b)-[:PUBLISHED_BY {published_year: $published_year}]->(p);
    """, {"title": title, "publisher": publisher, "published_year": published_year})
```
Then, we create a vector index on the `title_embedding` column of the `Book` table:
```python
# Create the index
conn.execute("CALL CREATE_VECTOR_INDEX('Book', 'title_vec_index', 'title_embedding');")
```
We now can perform a simple query to find the two books most similar to "The Quantum World" semantically.
```python
# Query the index and return the title
query_vector = model.encode("The Quantum World").tolist()
result = conn.execute("""
    CALL QUERY_VECTOR_INDEX('Book', 'title_vec_index', $query_vector, 2) RETURN nn.title ORDER BY distance;
    """, {"query_vector": query_vector})
print(result.get_as_df())
```

We can also combine the vector search with Cypher pattern matching to find publishers of the two books most similar to "The Quantum World".
```python
result = conn.execute("""
    CALL QUERY_VECTOR_INDEX('book', 'title_vec_index', $query_vector, 2) 
    WITH nn AS n, distance as dist 
    MATCH (n)-[:PUBLISHED_BY]->(p:Publisher) RETURN p.name ORDER BY dist;
    """, {"query_vector": query_vector})
print(result.get_as_df())
```

### Filtered Search
The `VECTOR` extension also supports performing vector search on a subset of records (filtered search). 
To perform a filtered search, first you need to define the filter through a projected graph with the following syntax:
```cypher
CALL CREATE_PROJECTED_GRAPH(
    'projected_graph_name', // Name of the projected graph
    {                      // Node tables to project
        'table_name': {
            'filter': 'predicate' // Optional predicate to filter nodes
        }
    },
    [                      // Relationship tables to project
        'table_name'
    ]
);
``` 

A projected graph is a subgraph (i.e., a subset of the original graph) that contains only the nodes and relationships that match the given table names and predicates. In this release, the projected graph is limited to single node table with simple filters on node properties.
We plan to allow more flexible filters that can take variables from Cypher pattern matching in the future.

For example, we can create a projected graph with a filter on `published_year` of `Book`, and then perform a filtered search combined with Cypher pattern matching to find publishers that publish books most similar to "The Quantum World" after 2010:
```python
# Create a projected graph with a filter on published_year of Book
conn.execute("CALL CREATE_PROJECTED_GRAPH('filtered_book', 
    {'Book': {'filter': 'n.published_year > 2010'}}, []);")
# Query the index on the projected graph
result = conn.execute("""
    CALL QUERY_VECTOR_INDEX('filtered_book', 'title_vec_index', $query_vector, 2) 
    WITH nn AS n, distance as dist 
    MATCH (n)-[:PUBLISHED_BY]->(p:Publisher) RETURN p.name ORDER BY dist;
    """, {"query_vector": query_vector})
print(result.get_as_df())
```

We've implemented a novel adaptive search algorithm that is predicate-agnostic with robust search performance. The idea is based on the research work done by [Gaurav Sehgal](https://www.linkedin.com/in/gaurav-sehgal-79abb9112/) and [Semih Salihoglu](https://cs.uwaterloo.ca/~ssalihog/), which is still under submission.
We will have a separate blog post to explain the technical details in the future.

### Performance
We first show the performance of index construction and query without any filters on [ann-benchmark](https://github.com/erikbern/ann-benchmarks).
The benchmark contains a set of datasets and test cases. 
We present the results on four datasets: `MNIST`, `SIFT`, `Glove-25`, and `Deep1B`, which cover various dimensions and scale.
The index is built with **8 threads** under default settings (`mu := 30, ml := 60, efc := 200`).
We perform all queries in the ann benchmark with **single thread** under the default setting `efs := 200`.
Each query is run through our Python API for 3 times, and we report the average latency.
The query template is as follows:
```python
conn.execute("""
    CALL QUERY_VECTOR_INDEX('project', 'tbl_vec_index', $q, 100) RETURN node.id, distance;
    """, {'q': vec})
```

| Dataset | Dimension | Num tuples | Construction (s) | Query (ms) |
| --- | --- | --- | --- | --- |
| MNIST | 784 | 60,000 | 9.8 | 4.1 |
| SIFT | 128 | 100,000 | 11.6 | 5.0 |
| Glove-25 | 25 | 1,183,514 | 74.4 | 5.2 |
| Deep1B | 96 | 9,990,000 | 1691.8 | 7.9 |

We can see from the above table that under various datasets, the average query latency is < 8ms.

Next we show the performance of our filtered search.
We apply a filter on the base table to control its selectivity to be 1%, 2%, 3%, 5%, 10%, 20%, 30%, 50%, 75% and 90%.
We randomly select 50 queries from the GIST query set, and for each selectivity, we apply the filter with a projected graph and perform the search.
The index is built with **8 threads** under the setting (`mu := 32, ml := 64, efc := 200`), and queried with **single thread** under the default setting `efs := 200`.

| Selectivity (%) | Query (ms) | Recall |
| --- | --- | --- |
| 1 | 16.7 | 1.00 |
| 3 | 16.4 | 1.00 |
| 5 | 17.2 | 0.99 |
| 10 | 148.3 | 1.00 |
| 20 | 42.1 | 0.99 |
| 30 | 32.3 | 0.99 |
| 40 | 7.5 | 0.90 |
| 50 | 8.2 | 0.91 |
| 75 | 11.4 | 0.92 |
| 90 | 11.9 | 0.92 |

All experiments above are performed on a Mac Mini desktop with M4 Pro chip, 64GB RAM, and 1TB SSD.

### Limitations
Our first release has the following limitations:
- The index is immutable after creation. You must drop and re-create the index to reflect changes in the underlying tables.
- We currently only support index over FLOAT array columns in Kuzu. More data type support are in our roadmap and will be added later.
- The index can only be created over a single column in node tables.


## Scan from Postgres with arbitrary SQL statements

In previous release, we introduced the [Postgres extension](https://docs.kuzudb.com/extensions/attach/rdbms/) which enabled scanning from PostgreSQL tables. This release further extends the capability with `SQL_QUERY` function, allowing users to execute arbitrary read-only SQL queries on attached PostgreSQL databases and retrieve the query result in kuzu.

Below shows an example of 
```sql
-- Attach a Postgres database
ATTACH 'dbname=university user=postgres host=localhost password=yourpassword port=5432' AS uw (dbtype postgres);
-- Scan from a Postgres query
CALL SQL_QUERY('uw', 'SELECT id, name, age FROM person WHERE age > 20') RETURN *;
-- Bulk insert from a Postgres query
CREATE NODE TABLE person(id INT PRIMARY KEY, name STRING, age INT);
COPY person FROM SQL_QUERY('uw', 'SELECT id, name, age FROM person WHERE age > 20');
```

## WASM with bundled extensions

In v0.8.0 we release a WebAssembly (WASM) version of Kuzu. One of the limitations of the WASM version was that it did not support extensions. This release ships a WASM version with several bundled extensions through static linking. The bundled extensions are
- Full-text search (fts)
- Json (json)
- Vector Index (vector)

## APIs and Ecosystem Integrations

### New Sync and Async APIs

Kuzu now provides both synchronous and asynchronous APIs for Python and Node.js bindings. For Python, synchronous API is the default choice while asynchronous API can be used in web frameworks like FastAPI. For Node.js, the asynchronous API is commonly used.


### Unity Catalog

### MCP

### Gdotv

## Performance Improvements

### Aggregation

We've been focusing on improving our aggregation performance in the last few releases starting from [0.8.0](https://blog.kuzudb.com/post/kuzu-0.8.0-release/#improved-parallel-aggregations).
In this release, we introduced more improvements on aggregation workloads, including distinct, hash aggregate and aggregate on distinct values. 
The performance again mainly comes from vectorizing computation and paralleling the final aggregation stage.
Here, we present a subset of the result that shows our improvements on aggregation heavy workloads in recent releases compared to `0.7.1`.

Benchmarks are from [ClickBench](https://github.com/ClickHouse/ClickBench/)'s benchmark suite, converted to cypher and run using a modified version of their benchmarking scripts (which uses our Python API to execute the queries and measures the total runtime of `kuzu.Connection.execute`).
We run each query twice from the same process, database and connection, and record the average query latency.
The queries were run on a machine with 2x AMD EPYC 7551 (total 64 cores 128 threads) and 512GB RAM.

| Query   | 0.7.1 (s)    | 0.8.0 (s)       | 0.8.2           | 0.9.0              |
|---------|--------------|-----------------|-----------------|--------------------|
| Q5      | 21           | 22.1            | 22.8            | 0.52 (**44x**)    |
| Q6      | 16.9         | 17.1            | 11              | 0.373 (**46x**)   |
| Q9      | 196          | 35.4 (6x)       | 2.46 (**79x**)  | 1.96 (**100x**)   |
| Q10     | 206          | 47.3 (4x)       | 2.62 (**79x**)  | 1.99 (**104x**)   |
| Q11     | 15           | 6.4 (2x)        | 0.681 (**22x**) | 0.633 (24x)   |
| Q12     | 28.6         | 6.88 (4x)       | 0.684 (**42x**) | 0.737 (39x)   |
| Q13     | 3.58         | 0.424 (**8x**)  | 0.427 (8x)      | 0.428 (8x)    |
| Q14     | 53           | 17.3 (3x)       | 0.903 (**59x**) | 0.879 (60x)   |
| Q15     | 4.03         | 0.458 (**9x**)  | 0.46 (9x)       | 0.446 (9x)    |
| Q16     | 5.99         | 0.75 (**8x**)   | 0.747 (8x)      | 0.749 (8x)    |
| Q17     | 8.36         | 1.01 (**8x**)   | 1.06 (8x)       | 1.05 (8x)     |
| Q18     | 9.13         | 0.922 (**10x**) | 1.06 (9x)       | 0.947 (10x)   |
| Q19     | 21           | 2.42 (**9x**)   | 2.72 (8x)       | 2.45 (9x)     |
| Q21     | 20.7         | 23.6            | 21.7            | 0.634 (**37x**)   |
| Q22     | 21           | 23.6            | 21.5            | 0.854 (**28x**)   |
| Q23     | 1.09e+03     | 1.11e+03        | 18.5 (**60x**)  | 0.949 (**1170x**) |
| Q24     | 22.5         | 24.6            | 23.1            | 3.24 (**8x**)     |
| Q31     | 3.47         | 0.526 (**7x**)  | 0.535 (6x)      | 0.544 (6x)    |
| Q32     | 5.36         | 0.771 (**7x**)  | 0.784 (7x)      | 0.787 (7x)    |
| Q33     | 48.7         | 6.22 (**8x**)   | 6.27 (8x)       | 6.38 (8x)     |
| Q34     | 15.8         | 1.67 (**9x**)   | 1.66 (10x)  | 1.66 (10x)    |
| Q35     | 17.9         | 1.75 (**10x**)  | 1.78 (10x)      | 1.8 (10x)     |
| Q36     | 7.84         | 0.946 (**8x**)  | 0.932 (8x)      | 0.898 (9x)    |

The above table shows query latency in seconds for each query in release `0.7.1`, `0.8.0`, `0.8.2` and `0.9.0`.
We also show the speedup of each release against `0.7.1`.
You can see that for some queries we can achieve up to 1170x speedup, and for many queries, we can achieve >=10x speedup.
If you have any aggregation heavy workloads, don't hesitate to upgrade to our new version and give it a try!
We will continue improving the performance of our aggregation and other core operators in the future.

### Full-text search index creation

The performance of index creationg is also improved in this release. The following benchmark is conducted using `ms-passage` dataset with 8.8M documents that take 2.9GB in raw size and on a machine with 2 AMD EPYC 7551 CPUs with 64 cores and 409GB of memory. The result is shown as follows:

| v0.8.0 | v0.9.0 | Speedup |
|--------|--------| ------- |
| 460s   | 108s   | **4.3x**    |

