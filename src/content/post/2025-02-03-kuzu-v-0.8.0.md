---
slug: "kuzu-0.8.0-release"
title: "KÃ¹zu 0.8.0 Release"
description: "Release announcement for KÃ¹zu 0.8.0"
pubDate: "Feb 03 2025"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher"]
---


It's 2025, and we're kicking off the year with the exciting release of KÃ¹zu 0.8.0. This release brings an exciting new feature that distinguishes KÃ¹zu from any other graph database out there -- KÃ¹zu-WASM for in-browser graph analytics -- run your graph database while keeping all data and compute within your browser session! Our extension ecosystem also has an exciting new addition: an `fts` extension for full-text search, so that you can run keyword-based search queries using BM25 in KÃ¹zu.

In addition to these new features, we've streamlined the developer workflow during relationship table creation by unifying `CREATE REL TABLE GROUP` into a single, flexible `CREATE REL TABLE` syntax. 
Along with these features, we've also improved our execution of aggregation queries significantly. In the following sections, we'll dive into more details.

## New Features

### KÃ¹zu-WASM
Starting from version 0.8.0, we are happy to release a [WebAssembly](https://webassembly.org/) (WASM) version of KÃ¹zu that runs within web browsers on a variety of devices.

Why is this exciting? With KÃ¹zu-WASM, you can:
- Perform interactive data analytics directly in the browser.
- Achieve low latency with fast in-browser graph analytics.
- Ensure data privacy if you need data to stay entirely in the browser.

This makes it very useful for use cases like building interactive in-browser graph analytics and visualization
in sensitive data environments, where users can analyze their data privately without transferring it to a server. 
To use KÃ¹zu-WASM, you have to install the `kuzu-wasm` package first `npm i kuzu-wasm` and then 
follow our [API documentation](https://docs.kuzudb.com/client-apis/wasm/) to integrate it into your projects. To see KÃ¹zu-WASM in action,
we have developed a version of KÃ¹zu Explorer, which is KÃ¹zu's browser-based graph visualization and CLO. You can check out this
demo here [here](https://demo-wasm.kuzudb.com/).

### Full-Text Search (fts) Extension

We're introducing an `fts` extension to enable full-text search capabilities using the [BM25](https://en.wikipedia.org/wiki/Okapi_BM25) scoring algorithm in KÃ¹zu.
The index can be built on one or multiple columns in a KÃ¹zu node tables. Similar to other
GDBMSs, we interpret each node as a "document".
Our implementation of FTS is native, i.e., we do not use any separate libraries, and similar to DuckDB's
fts feature and is based on the paper [Old Dogs Are Great at New Tricks](https://www.duckdb.org/pdf/SIGIR2014-column-stores-ir-prototyping.pdf) (read the paper
for a simple and elegant approach to support FTS natively in columnar database systems!).
In our implementation, we leveraged several graph-native capabilities of KÃ¹zu: 
words from source documents are stored as a KÃ¹zu node table, while the occurrences 
of words in "documents" are stored as a KÃ¹zu relationship table, which means
we use our default CSR join index on rel tables serves as an inverted index from words to documents,
and allows KÃ¹zu to answer queries very quickly (expect millisecond latencies).


To utilize the full-text search index, you have to install and load the `FTS` extension first.
```sql
INSTALL fts;
LOAD EXTENSION fts;
```

The `FTS` extension introduces three functions `CREATE_FTS_INDEX`, `QUERY_FTS_INDEX` and `DROP_FTS_INDEX` for creating, querying and dropping the index, respectively.

We use an example to demonstrate how the extension can be used to build an index on a `Books` table and search from it.
```cypher
# Create the book table and insert data to it
CREATE NODE TABLE Book (ID SERIAL, abstract STRING, author STRING, title STRING, PRIMARY KEY (ID));
CREATE (b:Book {abstract: 'An exploration of quantum mechanics.', author: 'Alice Johnson', title: 'The Quantum World'});
CREATE (b:Book {abstract: 'A magic journey through time and space.', author: 'John Smith', title: 'Chronicles of the Universe'});
CREATE (b:Book {abstract: 'An introduction to machine learning techniques.', author: 'Emma Brown', title: 'Learning Machines'});
CREATE (b:Book {abstract: 'A deep dive into the history of ancient civilizations.', author: 'Michael Lee', title: 'Echoes of the Past'});
CREATE (b:Book {abstract: 'A fantasy tale of dragons and magic.', author: 'Charlotte Harris', title: 'The Dragon\'s Call'});

# Build a fts-index named `book_index` on the book table
CALL CREATE_FTS_INDEX(
    'Book',   // Table name
    'book_index',   // Index name
    ['abstract', 'author', 'title'],   // Properties to build FTS index on
    stemmer := 'porter'   // Stemmer to use (optional: if left out, the English snowball stemmer is used)
)

# Query the `book_index` table
CALL QUERY_FTS_INDEX('Book', 'book_index', 'quantum machine')
RETURN node.title, score
ORDER BY score DESC;
```

Additionally, we support the `conjunctive` option for querying the index, which searches for tuples containing all the keywords in the query.
There are however also some limitations for now -- FTS indices can only be built on node tables and are immutable.
To refresh the index, you need to drop and recreate the index. We will improve these limitations in future releases.

## Usability Improvements
### Deprecation of `REL TABLE GROUP`

Until now, users had two ways to define relationships between node tables: `CREATE REL TABLE` and `CREATE REL TABLE GROUP`.
The former was limited to a single `FROM` and `TO` node table pair. With the latter, you had the flexibility to define relationships between **multiple** `FROM` and `TO` node table pairs in a single command.

Rather than imposing an additional cognitive load on the user while constructing the database schema, 
we've decided to deprecate the `CREATE REL TABLE GROUP` syntax, and instead let the `CREATE REL TABLE` syntax to be 
used with multiple `FROM` and `TO` pairs. 

The example below illustrates this. Say you have the following node tables:
```cypher
CREATE NODE TABLE comment(id INT64 PRIMARY KEY, content STRING);
CREATE NODE TABLE post(id INT64 PRIMARY KEY, author STRING);
```

You can now create a relationship table between multiple node table pairs using a single `CREATE REL TABLE` command 
(in prior versions you would have had to use the `CREATE REL TABLE GROUP` command).

```cypher
CREATE REL TABLE replyOf(FROM comment TO comment, FROM comment TO post, creation TIMESTAMP);
```

We note when copying data into a relationship table that has multiple `FROM` and `TO` pairs,
you now need to specify the FROM and TO node table names explicitly, as below:
```cypher
COPY replyOf FROM 'comment_replyOf_comment.csv' (from='comment', to='comment');
COPY replyOf FROM 'comment_replyOf_post.csv' (from='comment', to='post');
```

If the relationship table has only one source and destination node table, 
you do not have to specify the source and target node talbe names. That is, the
`COPY FROM` commands you used in the previous versions of KÃ¹zu are still valid. You can
find more detailed documentation [here](xxx).

### DataFrame usability improvements

#### Skipping erroneous rows when copying from DataFrame

In [v0.7.0](http://localhost:4321/post/kuzu-0.7.0-release/#allow-skipping-erroneous-rows-during-copyload-from), we introduced a feature that allows users to skip erroneous or malformed rows when copying 
data into tables from CSV and Parquet files. We now extend this support to DataFrames. 
Your `COPY FROM` commands from Pandas or Polars DataFrames can now be more robust to failure 
due to incorrectly parsed column data types or other problems.

When copying from a Pandas or Polars DataFrame into a KÃ¹zu table, you can specify an `IGNORE_ERRORS=TRUE` 
parameter, allowing you to skip rows that might trigger an exception.
More details can be found in our [docs](https://docs.kuzudb.com/import/copy-from-dataframe/#ignore-erroneous-rows). 
The same functionality also works for using `LOAD FROM`, i.e., when you scan the data from the DataFrame instead.

#### SKIP and LIMIT when scanning from DataFrame

The `SKIP` and `LIMIT` parameters are now available when scanning data using `LOAD FROM` for Pandas and Polars DataFrames.
For more details, please check our [docs](xxx).

## Performance improvement

We are a highly performance-oriented system and we continued optimizing the core query processor
of the system in this release as well.

### Improved parallel aggregations

We've implemented a new parallel hash aggregation mechanism that significantly improves the performance of 
aggregation-heavy queries.
In the new implementation, each thread first locally performs aggregation with a fixed-sized hash table.
When the local hash table is full, tuples are partitioned into `N` groups and flushed to `N` global queues. Each queue maintains tuples for a single group.
After the thread has exhausted its sources to perform local aggregation, it turns to read from a global queue to merge the final result for the group until all groups are aggregated.

We did benchmark evaluation on a few queries adapted from [ClickBench](https://benchmark.clickhouse.com) below. We used a machine
with X cores and Y memory to run the queries. The queries are as follows:

```cypher
// Q1
MATCH (h:hits) RETURN h.UserID, COUNT(*) ORDER BY COUNT(*) DESC LIMIT 10;
// Q2
MATCH (h:hits) RETURN h.UserID, h.SearchPhrase, COUNT(*) ORDER BY COUNT(*) DESC LIMIT 10;
// Q3
MATCH (h:hits) WHERE h.SearchPhrase <> '' RETURN h.SearchEngineID, h.SearchPhrase, COUNT(*) AS c ORDER BY c DESC LIMIT 10;
// Q4
MATCH (h:hits) WHERE h.SearchPhrase <> '' RETURN h.SearchPhrase, COUNT(*) AS c ORDER BY c DESC LIMIT 10;
```

| Query | # threads | 0.8.0 | 0.7.1 |
| ----- | --------- | ----- | ----- |
| Q1 | 1 | 12.6s | 11.3s |
| Q1 | 4 | 5.7s | 6.5s |
| Q1 | 16 | 2.86s | 5.7s |
| Q1 | 64 | 2.14s | 5.9s |
| Q2 | 1 | 19.6s | 18s |
| Q2 | 4 | 7.6s | 10.3s |
| Q2 | 16 | 3.70s | 8.5s |
| Q2 | 64 | 2.66s | 8.3s |
| Q3 | 1 | 7.7s | 8.2s |
| Q3 | 4 | 2.9 | 4.4s |
| Q3 | 16 | 1.55s | 3.8s |
| Q3 | 64 | 0.84s | 3.8s |
| Q4 | 1 | 6.9s | 8.4s |
| Q4 | 4 | 2.8s | 4.3s |
| Q4 | 16 | 1.33s | 3.67s |
| Q4 | 64 | 0.55s | 3.65s |

## Closing remarks

We extend our thank to the entire KÃ¹zu team and our incredible
interns who have worked very hard to make this release possible. We are thrilled to
see KÃ¹zu becoming a more and more feature-rich databse and encourage all of you try out these new features!
As usual please share your experiences with us â€“ your feedback continues to
shape KÃ¹zu's evolution. From the sometimes unreasonable cold of ðŸ‡¨ðŸ‡¦, where it was -23 Â°C last week,
enjoy the new release! ðŸŽ‰ ðŸŽ‰

Till next time!

ps: Oh, and no tariffs to ðŸ‡ºðŸ‡¸; it's free and open-sourced!