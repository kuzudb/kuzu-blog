---
slug: "kuzu-0.8.0-release"
title: "Kùzu 0.8.0 Release"
description: "Release announcement for Kùzu 0.8.0"
pubDate: "Feb 03 2025"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher"]
---


It's 2025, and we're kicking off the year with a bang by releasing Kùzu 0.8.0. This release brings an exciting new feature that distinguishes Kùzu from any other graph database out there -- Kùzu-WASM for in-browser graph analytics -- run your graph database while keeping all data and compute within your browser session! Our extension ecosystem also has an exciting new addition: an `fts` extension for full-text search, so that you can run keyword-based search queries using BM25 in Kùzu.

In addition to these new features, we've streamlined the developer workflow during relationship table creation by unifying `CREATE REL TABLE GROUP` into a single, flexible `CREATE REL TABLE` syntax. Along with these features, we've also supercharged our aggregation performance for faster, more scalable queries. In the following sections, we'll dive into more details.

## New Features

### Kùzu-WASM
Starting from version 0.8.0, we are happy to support [WebAssembly](https://webassembly.org/) (WASM), enabling Kùzu to run within web browsers on a variety of devices.

Why is this exciting? With Kùzu-WASM, you can:
- Perform interactive data analytics directly in the browser.
- Achieve low latency with fast graph analytics.
- Ensure data privacy, as data stays entirely in the browser.

This makes it very useful for use cases like building interactive dashboards in sensitive data environments, where users can explore data privately without transferring it to a server. Additionally, it offers the flexiblity to use Kùzu as an "ephemeral" graph compute engine, where you can run ad-hoc analyses within web-based applications without the need to persist data to a local machine.

To use Kùzu-WASM, you have to install the `kuzu-wasm` package first.
```bash
 npm i kuzu-wasm
 ```

Then you can follow our [API documentation](https://docs.kuzudb.com/client-apis/wasm/) to integrate it into your projects.
// TODO(Chang): need a brief description on how users can get started with Kùzu-WASM.

Please try out Kùzu-WASM with our [guide](xxx), or explore the WASM-based explorer [here](xxx).

### Full-Text Search (fts) Extension

We're introducing an `fts` extension to enable full-text search capabilities via BM25 in Kùzu.
You can now search for word occurrences across collections of strings in Kùzu tables, as you may be familiar with from other systems that offer this functionality. The index can be built on one or multiple columns in a Kùzu node table, and each tuple in the table can be interpreted as a document.

To utilize the full-text search index, you have to install and load the `FTS` extension first.
```sql
INSTALL fts;
LOAD EXTENSION fts;
```

The `FTS` extension introduces two functions `CREATE_FTS_INDEX` and `QUERY_FTS_INDEX` for creating and querying the index, respectively.

We use an example to demonstrate how the extension can be used to build an index on a `Books` table and search from it.
```cypher
// Schema of the Books table
CREATE NODE TABLE Book (ID SERIAL, abstract STRING, author STRING, title STRING, PRIMARY KEY (ID));
... ...
// Create a full-text search index on top of string columns.
CALL CREATE_FTS_INDEX('Books', 'BooksFTSIndex', ['abstract', 'author', 'title']);
// Query keywords from the index.
CALL QUERY_FTS_INDEX('Books', 'BooksFTSIndex', 'graph databases') 
RETURN _node.title, score
ORDER BY score DESC; ;
```

Additionally, we support the `conjunctive` option for querying the index, which searches for tuples containing all the keywords in the query.

Our implementation of FTS is based on the paper [Old Dogs Are Great at New Tricks](https://www.duckdb.org/pdf/SIGIR2014-column-stores-ir-prototyping.pdf), which leverages columnar storage and parallel query processing techniques of database systems for building scalable and high-performance full-text search indexes.
To enable ultra-fast pattern matching in Kùzu, we leverage a graph-native approach: Words from source documents are stored in a node table, while their contextual occurrences in the documents are modelled as a relationship table. The optimized graph structure, combined with our state-of-the-art query engine, allows Kùzu to retrieve patterns in milliseconds.
Note that the full text search index has some limitations for now -- it can only be built on node tables and are immutable. To refresh the index, you need to drop and recreate the index. We will improve these limitations in future releases.

## Usability Improvements
### Deprecation of `REL TABLE GROUP`

Until now, users have had two ways to define relationship between node tables: `CREATE REL TABLE` and `CREATE REL TABLE GROUP`.
The former used to be limited to a single `FROM` and `TO` node table pair. With the latter, you now have the flexibility to define relationships between **multiple** `FROM` and `TO` node table pairs in a single command.

Rather than imposing an additional cognitive load on the user while constructing the database schema, we've decided to deprecate the `CREATE REL TABLE GROUP` syntax, and instead follow the `CREATE REL TABLE` syntax to be defined with multiple `FROM` and `TO` pairs. The example below illustrates this.

Say you have the following node tables:
```cypher
CREATE NODE TABLE comment(id INT64 PRIMARY KEY, content STRING);
CREATE NODE TABLE post(id INT64 PRIMARY KEY, author STRING);
```

You can now create a relationship table between multiple node table pairs using a single `CREATE REL TABLE` command (in prior versions you would have had to create a relationship table group).

```cypher
// Define the relationship between the two node tables in a single `CREATE REL TABLE` command.
CREATE REL TABLE replyOf(FROM comment TO comment, FROM comment TO post, creation TIMESTAMP);
```

Copying into the `replyOf` table that has multiple `FROM` and `TO` pairs can be done as follows. Note how we copy from multiple different files into the relationship table, simply by specifying the source and target node table names.
```cypher
// Copy from multiple different files into the relationship table.
COPY replyOf FROM 'comment_replyOf_comment.csv' (from='comment', to='comment');
COPY replyOf FROM 'comment_replyOf_post.csv' (from='comment', to='post');
```

Using `COPY FROM` on relationship tables with a single `FROM` and `TO` node table pair is the same as before.

### DataFrame usability improvements

#### Skip erroneous rows when copying from DataFrame

In [v0.7.0](http://localhost:4321/post/kuzu-0.7.0-release/#allow-skipping-erroneous-rows-during-copyload-from), we introduced a feature that allows users to skip erroneous or malformed rows when copying into tables _files_ (CSV, Parquet). We now extend this support to DataFrames in v0.8.0. Your `COPY FROM` pipelines from DataFrames can now be more robust to failure due to incorrectly parsed column data types, and so on.

When copying from a Pandas or Polars DataFrame into a Kùzu table, you can specify `IGNORE_ERRORS=TRUE` a parameter, allowing you to skip rows that might trigger an exception. This way, you can ingest all rows that were correctly parsed without your entire ingestion pipeline failing due to one single malformed row.
More details can be found in our [docs](https://docs.kuzudb.com/import/copy-from-dataframe/#ignore-erroneous-rows). The same functionality also works for using `LOAD FROM`, i.e., when you scan the data from the DataFrame instead.

#### SKIP and LIMIT when scanning from DataFrame

The `SKIP` and `LIMIT` parameters are now available when scanning using `LOAD FROM` for Pandas and Polars DataFrames. These options allow skipping the first `n` rows or limiting the number of rows scanned to `k` during `LOAD FROM`. For more details, please check our [docs](xxx).

## Performance improvement

We continue with advancing one of the core tenets of Kùzu's philosophy: query performance. We list an important performance improvement that's shipped in this release below.

### Improved parallel hash aggregate

We've implemented a new parallel hash aggregation mechanism to significantly improve scalability and performance for aggregation-heavy queries.

In the new implementation, each thread first locally performs aggregation with a fixed-sized hash table.
When the local hash table is full, tuples are partitioned into `N` groups and flushed to `N` global queues. Each queue maintains tuples for a single group.
After the thread has exhausted its sources to perform local aggregation, it turns to read from a global queue to merge the final result for the group until all groups are aggregated.

We did benchmark evaluation on a few queries adapted from [ClickBench](https://benchmark.clickhouse.com) below.

```cypher
// Q1
MATCH (h:hits) RETURN h.UserID, COUNT(*) ORDER BY COUNT(*) DESC LIMIT 10;
// Q2
MATCH (h:hits) RETURN h.UserID, h.SearchPhrase, COUNT(*) ORDER BY COUNT(*) DESC LIMIT 10;
// Q3
MATCH (h:hits) WHERE h.SearchPhrase <> '' RETURN h.SearchEngineID, h.SearchPhrase, COUNT(*) AS c ORDER BY c DESC LIMIT 10;
// Q4
MATCH (h:hits) WHERE h.SearchPhrase <> '' RETURN h.SearchPhrase, COUNT(*) AS c ORDER BY c DESC LIMIT 10;
```

| Query | # threads | 0.8.0 | 0.7.1 |
| ----- | --------- | ----- | ----- |
| Q1 | 1 | 12.6s | 11.3s |
| Q1 | 4 | 5.7s | 6.5s |
| Q1 | 16 | 2.86s | 5.7s |
| Q1 | 64 | 2.14s | 5.9s |
| Q2 | 1 | 19.6s | 18s |
| Q2 | 4 | 7.6s | 10.3s |
| Q2 | 16 | 3.70s | 8.5s |
| Q2 | 64 | 2.66s | 8.3s |
| Q3 | 1 | 7.7s | 8.2s |
| Q3 | 4 | 2.9 | 4.4s |
| Q3 | 16 | 1.55s | 3.8s |
| Q3 | 64 | 0.84s | 3.8s |
| Q4 | 1 | 6.9s | 8.4s |
| Q4 | 4 | 2.8s | 4.3s |
| Q4 | 16 | 1.33s | 3.67s |
| Q4 | 64 | 0.55s | 3.65s |

## Closing remarks

We extend our heartfelt gratitude to the entire Kùzu team, our external contributors and our incredible
interns who have poured their attention and dedication into making this release possible. As we look ahead,
we're thrilled about the growing Kùzu extension ecosystem and the possibilities that lie ahead for innovative
applications that use a modern graph database like Kùzu. We encourage all users to try out these new features,
especially Kùzu-WASM and the FTS extension, and share their experiences with us – your feedback continues to
shape Kùzu's evolution. Let's keep going! 🎉
