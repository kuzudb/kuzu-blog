---
slug: "kuzu-0.8.0-release"
title: "KÃ¹zu 0.8.0 Release"
description: "Release announcement for KÃ¹zu 0.8.0"
pubDate: "Feb 03 2025"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher"]
---

We're thrilled to announce the release of KÃ¹zu 0.8.0! 
This version introduces KÃ¹zu WASM, enabling browser-based graph analytics, and a new extension, `fts`, to support full-text search functionality. 
Additionally, we've improved our usability by consolidating `CREATE REL TABLE GROUP` into the unified `CREATE REL TABLE` syntax and have greatly improved the performance of our aggregation for better query scalability.

## New Features
### KÃ¹zu WASM
We're happy to announce that KÃ¹zu 0.8.0 is the first release to support [WebAssembly](https://webassembly.org/) (WASM), which enables KÃ¹zu to run within web browsers on a variety of devices.

With KÃ¹zu WASM, you can:
- Perform interactive data analytics directly in the browser.
- Achieve low latency with fast graph analytics.
- Ensure data privacy, as data stays entirely in the browser.

This makes it ideal for use cases like building interactive dashboards, where users can explore data privately without transferring it to a server.

To useÂ KÃ¹zu WASM, you have to install the `kuzu-wasm` package first.
```bash
 npm i kuzu-wasm
 ```

Then you can follow our [API documentation](xx) to integrate it into your projects.
// TODO: need a brief description on how users can get started with kuzu wasm.

Please try out KÃ¹zu WASM with our [guide](xxx), or explore the WASM-based explorer [here](xxx).

### Full-Text Search (fts) Extension
We're introducing a new extension `fts` to enable full-text search capabilities in KÃ¹zu.
This extension allows users to search for word occurrences across collections of strings in KÃ¹zu tables.
The index can be built on one or multiple columns in a KÃ¹zu node table, and each tuple in the table can be interpreted as a document.

To utilize the full-text search index, you have to install and load the `FTS` extension first.
```sql
INSTALL fts;
LOAD EXTENSION fts;
```

The `FTS` extension introduces two functions `CREATE_FTS_INDEX` and `QUERY_FTS_INDEX` for creating and querying the index, respecitively.

We use an example to demonstrate how the extension can be used to build an index on a `Books` table and search from it.
```cypher
// Schema of the Books table
CREATE NODE TABLE Book (ID SERIAL, abstract STRING, author STRING, title STRING, PRIMARY KEY (ID));
... ...
// Create a full-text search index on top of string columns.
CALL CREATE_FTS_INDEX('Books', 'BooksFTSIndex', ['abstract', 'author', 'title']);
// Query keywords from the index.
CALL QUERY_FTS_INDEX('Books', 'BooksFTSIndex', 'databases, sql') 
RETURN _node.title, score
ORDER BY score DESC; ;
```

Additionally, we support the `conjunctive` option for querying the index, which searchs for tuples containing all the keywords in the query.

The implementation of FTS is based on the paper [Old Dogs Are Great at New Tricks](https://www.duckdb.org/pdf/SIGIR2014-column-stores-ir-prototyping.pdf), which leverages columnar storage and parallel query processing techniques of database systems into building scalable and high-performance full-text search indexes.
Internally we utilize KÃ¹zu node and rel tables to store the index...
*// TODO: add brief description here on how we model the index as a graph and how we perform the search on the graph in KÃ¹zu.*

Note that the full text search index has some limitations for now that it can only be built on node tables and are immutable. To refresh the index, you need to drop and recreate the index. We will improve these limitations in future releases.

## Usability Improvements
### Deprecation of rel table group
Until now, users have two ways to define relationship between node tables: `CREATE REL TABLE` and `CREATE REL TABLE GROUP`.
The former one is limited to only one FROM and TO node table pair, while the latter one has the flexibility to be defined between multiple FROM and TO node table pairs.
However, this distinction imposes an additional cognitive load on users.
From this version on, we deprecate`CREATE REL TABLE GROUP`, and allow `CREATE REL TABLE` to be defined with multiple FROM and TO pairs.
```cypher
CREATE NODE TABLE comment(id INT64 PRIMARY KEY, content STRING);
CREATE NODE TABLE post(id INT64 PRIMARY KEY, author STRING);
CREATE REL TABLE replyOf(FROM comment TO comment, FROM comment TO post, creation TIMESTAMP);
```

When copy into a rel table with multiple FROM and TO pairs, users have to copy for each pair at one time through the `FROM` and `TO` option in `COPY FROM` statement, while the `COPY FROM` statement on rel tables with a single FROM and TO pair remains the same.
```cypher
COPY replyOf FROM 'comment_replyOf_comment.csv' (FROM comment TO comment);
COPY replyOf FROM 'comment_replyOf_post.csv' (FROM comment TO post);
```

### Improvements around DataFrame
#### Skip errorneous rows when copying from DataFrame
In the previous release [0.7.0](http://localhost:4321/post/kuzu-0.7.0-release/#allow-skipping-erroneous-rows-during-copyload-from), we have supported skipping errorneous rows when copying into tables from CSV and Parquet files. We now extend this support to DataFrame in this release.
You can specify `IGNORE_ERRORS=TRUE` in a `COPY FROM` statement, you can skip rows that trigger exceptions, and continue ingesting all other rows.
More details can be found in our [docs](xxx). The same functionality also works for using `LOAD FROM`.

#### Support SKIP and LIMIT options when `LOAD FROM` from DataFrame
The SKIP and LIMIT parameters are now available for all Python DataFrames, including Pandas-backed ones. These options allow skipping the first `n` rows or limiting the number of rows scanned during `LOAD FROM`. For more details, please check our [docs](xxx).

## Performance improvement
As always, we remain committed to enhancing KÃ¹zu's performance.
### Improved parallel hash aggregate
Weâ€™ve implemented a new parallel hash aggregation mechanism to significantly improve scalability and performance for aggregation-heavy queries.

In the new implementation, each thread first locally performs aggregation with a fixed-sized hash table.
When the local hash table is full, tuples are partitioned into `N` groups and flushed to `N` global queues. Each queue maintains tuples for a single group.
After the thread has exhausted its sources to perform local aggregation, it turns to read from a global queue to merge the final result for the group until all groups are aggregated.

We did benchmark evaluation on a few queries adapted from [ClickBench](https://benchmark.clickhouse.com) below.

```cypher
// Q1
MATCH (h:hits) RETURN h.UserID, COUNT(*) ORDER BY COUNT(*) DESC LIMIT 10;
// Q2
MATCH (h:hits) RETURN h.UserID, h.SearchPhrase, COUNT(*) ORDER BY COUNT(*) DESC LIMIT 10;
// Q3
MATCH (h:hits) WHERE h.SearchPhrase <> '' RETURN h.SearchEngineID, h.SearchPhrase, COUNT(*) AS c ORDER BY c DESC LIMIT 10;
// Q4
MATCH (h:hits) WHERE h.SearchPhrase <> '' RETURN h.SearchPhrase, COUNT(*) AS c ORDER BY c DESC LIMIT 10;
```

| Query | # threads | 0.8.0 | 0.7.1 |
| ----- | --------- | ----- | ----- |
| Q1 | 1 | xx | xx |
| Q1 | 4 | xx | xx |
| Q1 | 16 | xx | xx |
| Q1 | 64 | xx | xx |
| Q2 | 1 | xx | xx |
| Q2 | 4 | xx | xx |
| Q2 | 16 | xx | xx |
| Q2 | 64 | xx | xx |
| Q3 | 1 | xx | xx |
| Q3 | 4 | xx | xx |
| Q3 | 16 | xx | xx |
| Q3 | 64 | xx | xx |
| Q4 | 1 | xx | xx |
| Q4 | 4 | xx | xx |
| Q4 | 16 | xx | xx |
| Q4 | 64 | xx | xx |

## Closing remarks
Thank you for being part of the KÃ¹zu journey. Weâ€™re excited for you to explore KÃ¹zu 0.8.0 and look forward to your feedback! ðŸŽ‰
